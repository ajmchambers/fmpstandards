/**
 * =====================================================
 * Debug ( )
 * 
 * PARAMETERS:
 *		none
 *
 * RETURNS:
 *		[string] A list of informative values
 * 		about the current FMP environment.
 *
 * DEPENDENCIES:
 * 		Developer ()
 *
 * NOTES:
 *
 * HISTORY:
 *		MODIFIED on 2022-AUG-10 by Matt Petrowsky
 *			- Refactored with some historical flair.
 *		MODIFIED on 2013-JAN-25 by Matt Petrowsky
 *			- Updated to be recursive and use better output.
 *		RELEASED on 2010-10-09 Matt Petrowsky
 *
 * =====================================================
 * 
 */

If ( Developer;
	Let ( [
		~input = List (
			"Environment";
			"	ApplicationVersion";
			"	ApplicationArchitecture";
			"	ApplicationLanguage";
			"	SystemVersion";
			"	SystemPlatform";
			"	SystemLanguage";
			"	HostName";
			"	HostApplicationVersion";
			"	HostIPAddress";
			"	SystemIPAddress";
			"	CurrentTimeStamp";
			"	CurrentHostTimeStamp";
			"	CurrentTimeUTCMilliseconds";
			"	InstalledFMPlugins";
			"	PersistentID";
			"	UseSystemFormatsState";
			"	Device";
			"	SystemAppearance";
			"	ActiveModifierKeys";
			"Network";
			"	ConnectionState";
			"	ConnectionAttributes";
			"	SystemNICAddress";
			"	NetworkType";
			"	NetworkProtocol";
			"	MultiUserState";
			"Errors";
			"	LastError";
			"	LastODBCError";
			"	LastExternalErrorDetail";
			"File";
			"	FileName";
			"	FileSize";
			"	EncryptionState";
			"	CustomMenuSetName";
			"	OpenDataFileInfo";
			"User";
			"	AccountName";
			"	AccountType";
			"	AccountGroupName";			
			"	AccountPrivilegeSetName";
			"	CurrentPrivilegeSetName";
			"	AccountExtendedPrivileges";
			"	CurrentExtendedPrivileges";
			"	UserName";
			"	UserCount";
			"Layout";
			"	LayoutName";
			"	LayoutNumber";
			"	LayoutTableName";
			"	LayoutViewState";
			"	LayoutAccess";
			"	ActiveLayoutObjectName";
			"	ActivePortalRowNumber";
			"	LayoutCount";
			"Records";
			"	RecordID";
			"	RecordNumber";
			"	ActiveRecordNumber";
			"	RecordOpenState";
			"	RecordOpenCount";
			"	RecordAccess";
			"	RecordModificationCount";
			"	SortState";
			"	FoundCount";
			"	TotalRecordCount";
			"	RequestCount";
			"	RequestOmitState";
			"	QuickFindText";
			"Field";
			"	ActiveFieldName";
			"	ActiveFieldTableName";
			"	ActiveFieldContents";
			"	ActiveRepetitionNumber";
			"	ActiveSelectionStart";
			"	ActiveSelectionSize";
			"	CalculationRepetitionNumber";
			"	ModifiedFields";
			"Script";
			"	ScriptName";
			"	ScriptParameter";
			"	ScriptResult";
			"	ScriptAnimationState";
			"	ErrorCaptureState";
			"	AllowAbortState";
			"Triggers";
			"	TriggerCurrentPanel";
			"	TriggerExternalEvent";
			"	TriggerGestureInfo";
			"	TriggerKeystroke";
			"	TriggerModifierKeys";
			"	TriggerTargetPanel";
			"Paths";
			"	TemporaryPath";
			"	DesktopPath";
			"	DocumentsPath";
			"	FileMakerPath";
			"	FilePath";
			"	PreferencesPath";
			"	SystemDrive";
			"Mobile";
			"	RegionMonitorEvents";
			"	TouchKeyboardState";
			"Window";
			"	AllowFormattingBarState";
			"	StatusAreaState";
			"	MenubarState";
			"	TextRulerVisible";
			"	ScreenDepth";
			"	ScreenHeight";
			"	ScreenScaleFactor";
			"	ScreenWidth";
			"	WindowContentHeight";
			"	WindowContentWidth";
			"	WindowDesktopHeight";
			"	WindowDesktopWidth";
			"	WindowHeight";
			"	WindowLeft";
			"	WindowMode";
			"	WindowName";
			"	WindowOrientation";
			"	WindowStyle";
			"	WindowTop";
			"	WindowVisible";
			"	WindowWidth";
			"	WindowZoomLevel";
			"	HighContrastState";
			"	PageCount";
			"	PageNumber";
			"	PrinterName";
		);
		// Do YOU remember the coffee cup days?
		$$~☕️ = If ( IsEmpty ( $$~☕️ ) ; ~input ; $$~☕️ );
		~tab = "	";
		~line = GetValue ( ~input ; ValueCount ( $$~☕️ ) );
		~eval = If ( Left ( ~line ; 1 ) = ~tab ; // evaluate lines prefixed with tabs
			Let ( [
				~function = Trim ( ~line );
				~padding = "                              "; // 30 chars is longest function name
				~result = Evaluate ( "Get(" & ~function & ") & \"\"" )
			];
				~function
				& Left ( ~padding ; Length ( ~padding ) - Length ( ~function ) ) // spacing out result
				& If ( ValueCount ( ~result ) > 1; // some functions return multiple lines
					Substitute ( ~result ; ¶ ; ¶ & ~tab & Left ( ~padding ; Length ( ~padding ) - 1 ) );
					~result
				)
			);

			/*else*/

			~line
		);

		// How about the filing cabinet?
		$$~🗄 = List ( ~eval ; $$~🗄 );
		$$~☕️ = LeftValues ( $$~☕️ ; ValueCount ( $$~☕️ ) - 1 )
	];
		If ( IsEmpty ( $$~☕️ );
			Let ( [ ~result = $$~🗄 ; $$~🗄 = "" ] ; ~result );
			Debug
		)
	)
)